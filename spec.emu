<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Module Fragments
stage: 1
contributors: Daniel Ehrenberg, Nicol√≤ Ribaudo
</pre>

<emu-clause id="sec-module-declarations">
  <h1><ins>Module Declarations</ins></h1>

  <emu-note type="editor">
    <p>This proposal builds on top of <a href="https://tc39.es/proposal-js-module-blocks/">the Module Blocks proposal</a>, which introduces the following production:</p>
    <emu-grammar type="definition">
      ModuleExpression :
        `module` [no LineTerminator here] `{` ModuleBody? `}`
    </emu-grammar>
    <p>More specifically, it'a diff on top of <a href="https://github.com/tc39/proposal-js-module-blocks/pull/75">tc39/proposal-js-module-blocks#75</a>, which is itself a diff on top of <a href="https://github.com/tc39/ecma262/pull/2905">tc39/ecma262#2905</a>.</p>
  </emu-note>

  <h2>Syntax</h2>
  <emu-grammar type="definition">
    ModuleDeclaration :
      `module` [no LineTerminator here] Identifier `{` ModuleBody? `}`
  </emu-grammar>

  <emu-clause id="sec-module-declarations-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>

    <emu-grammar>
      ModuleDeclaration : `module` Identifier `{` ModuleBody? `}`
    </emu-grammar>
    <emu-alg>
      1. Return ~empty~.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-module-declaration-instantiatemoduleobject" type="sdo">
    <h1>
      Runtime Semantics: InstantiateModuleDeclaration ( ): a ModuleBlock object
    </h1>
    <dl class="header">
    </dl>

    <emu-grammar>
      ModuleDeclaration : `module` Identifier `{` ModuleBody? `}`
    </emu-grammar>
    <emu-alg>
      1. Let _name_ be the StringValue of |Identifier|.
      1. Let _currentScriptOrModule_ be GetActiveScriptOrModule().
      1. Assert: _currentScriptOrModule_ is not *null*.
      1. Let _moduleDeclaration_ be the Record in _currentScriptOrModule_.[[VisibleModuleDeclarations]] with [[Name]] equal to _name_.
      1. Assert: _moduleDeclaration_ exists and is unique.
      1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%, &laquo; [[ModuleRecord]], [[SourceText]] &raquo;).
      1. Set _moduleBlock_.[[ModuleRecord]] to _moduleDeclaration_.[[Module]].
      1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleDeclaration|.
      1. Return _moduleBlock_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations" number="8">
  <h1>Syntax-Directed Operations</h1>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis" number="2">
    <h1>Scope Analysis</h1>

    <emu-clause id="sec-static-semantics-boundnames" type="sdo" number="1">
      <h1>Static Semantics: BoundNames ( ): a List of Strings</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        <ins>ModuleDeclaration : `module` Identifier `{` ModuleBody? `}`</ins>
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of Identifier.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" type="sdo" number="3">
      <h1>Static Semantics: IsConstantDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        <ins>ModuleDeclaration : `module` Identifier `{` ModuleBody? `}`</ins>
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" type="sdo" number="5">
      <h1>Static Semantics: LexicallyScopedDeclarations ( ): a List of Parse Nodes</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        <ins>ModuleItem : ModuleDeclaration</ins>
      </emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is |ModuleDeclaration|.
      </emu-alg>
      <emu-grammar>
        <ins>ScriptItem : ModuleDeclaration</ins>
      </emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is |ModuleDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-containsundefinedmodulereference" type="sdo" number="12">
      <h1>
        <ins>
          Static Semantics: ContainsUndefinedModuleReference (
            _declaredModules_: a List of Strings,
          ): a Boolean
        </ins>
      </h1>
      <dl class="header">
      </dl>
      <p>Unless explicitly specified otherwise, all nonterminals have an implicit definition for ContainsUndefinedModuleReference with argument _declaredModules_.The implicit definition applies ContainsUndefinedModuleReference with argument _declaredModules_ to the nonterminal's inner nonterminals, and returns *true* if it's *true* for any of them. For example, ContainsUndefinedModuleReference of |ExponentiationExpression| is implicitly defined as follows:</p>
      <emu-grammar example>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg example>
        1. Let _hasUndefinedRef_ be ContainsUndefinedModuleReference of |UpdateExpression| with argument _declaredModules_.
        1. If _hasUndefinedRef_ is *true*, return *true*.
        1. Return ContainsUndefinedModuleReference of |ExponentiationExpression| with argument _declaredModules_.
      </emu-alg>

      <p>The following productions have a different definition of ContainsUndefinedModuleReference:</p>

      <emu-grammar>
        ModuleSpecifier : Identifier
      </emu-grammar>
      <emu-alg>
        1. Let _reference_ be the StringValue of |Identifier|.
        1. If _reference_ is in _declaredModules_, return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-grammar>
        ModuleBody : ModuleItemList
      </emu-grammar>
      <emu-alg>
        1. Let _localDeclaredModules_ be DeclaredModuleNames of |ModuleItemList|.
        1. Let _allDeclaredModules_ be the list-concatenation of _declaredModules_ and _localDeclaredModules_.
        1. Return ContainsUndefinedModuleReference of |ModuleItemList| with argument _allDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        ScriptBody : ScriptItemList
      </emu-grammar>
      <emu-alg>
        1. Assert: _declaredModules_ is an empty List.
        1. Let _localDeclaredModules_ be DeclaredModuleNames of |ScriptItemList|.
        1. Return ContainsUndefinedModuleReference of |ScriptItemList| with argument _localDeclaredModules_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-declaredmodulenames" type="sdo">
      <h1>
        <ins>
          Static Semantics: DeclaredModuleNames ( ): a Boolean
        </ins>
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ModuleDeclaration : `module` Identifier `{` ModuleBody? `}`
      </emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is the StringValue of |Identifier|.
      </emu-alg>

      <emu-grammar>
        ModuleItemList : ModuleItemList ModuleItem
      </emu-grammar>
      <emu-alg>
        1. Let _names1_ be DeclaredModuleNames of |ModuleItemList|.
        1. Let _names2_ be DeclaredModuleNames of |ModuleItem|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>

      <emu-grammar>
        ScriptItemList : ScriptItemList ScriptItem
      </emu-grammar>
      <emu-alg>
        1. Let _names1_ be DeclaredModuleNames of |ScriptItemList|.
        1. Let _names2_ be DeclaredModuleNames of |ScriptItem|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>

      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-note type="editor">
        TODO: Allow importing and exporting module declarations.
      </emu-note>

      <emu-grammar>
        ModuleItem : StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return an empty List.
      </emu-alg>

      <emu-grammar>
        ScriptItem : StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return an empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-rawmoduledeclarations" type="sdo">
      <h1>
        <ins>
          Static Semantics: RawModuleDeclarations ( ): a List of Records with fields [[Name]] (a String) and [[Body]] (a String)
        </ins>
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ModuleDeclaration : `module` Identifier `{` `}`
      </emu-grammar>
      <emu-alg>
        1. Let _name_ be the StringValue of |Identifier|.
        1. Return a List whose sole element is the Record { [[Name]]: _name_, [[Body]]: *""* }.
      </emu-alg>

      <emu-grammar>
        ModuleDeclaration : `module` Identifier `{` ModuleBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _name_ be the StringValue of |Identifier|.
        1. Let _body_ be the source text matched by |ModuleBody|.
        1. Return a List whose sole element is the Record { [[Name]]: _name_, [[Body]]: _body_ }.
      </emu-alg>

      <emu-grammar>
        ModuleItemList : ModuleItemList ModuleItem
      </emu-grammar>
      <emu-alg>
        1. Let _decls1_ be RawModuleDeclarations of |ModuleItemList|.
        1. Let _decls2_ be RawModuleDeclarations of |ModuleItem|.
        1. Return the list-concatenation of _decls1_ and _decls2_.
      </emu-alg>

      <emu-grammar>
        ScriptItemList : ScriptItemList ScriptItem
      </emu-grammar>
      <emu-alg>
        1. Let _decls1_ be RawModuleDeclarations of |ScriptItemList|.
        1. Let _decls2_ be RawModuleDeclarations of |ScriptItem|.
        1. Return the list-concatenation of _decls1_ and _decls2_.
      </emu-alg>

      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-note type="editor">
        TODO: Allow importing and exporting module declarations.
      </emu-note>

      <emu-grammar>
        ModuleItem : StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return an empty List.
      </emu-alg>

      <emu-grammar>
        ScriptItem : StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return an empty List.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        <del>StatementList[~Yield, ~Await, ~Return]</del>
        <ins>ScriptItemList</ins>

      <ins>
      ScriptItemList :
        ScriptItemList ScriptItem
      </ins>

      <ins>
      ScriptItem :
        ModuleDeclaration
        StatementListItem[~Yield, +Await, ~Return]
      </ins>
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors" number="1">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |ScriptBody| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |ScriptBody| also occurs in the VarDeclaredNames of |ScriptBody|.
        </li>
        <li>
          <ins>It is a Syntax Error if ContainsUndefinedModuleReference of |ScriptBody| with argument a new empty List is *true*.</ins>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-script-records" number="4">
      <h1>Script Records</h1>

      <p>A <dfn id="script-record" variants="Script Records">Script Record</dfn> encapsulates information about a script being evaluated. Each script record contains the fields listed in <emu-xref href="#table-script-records"></emu-xref>.</p>

      <emu-table id="table-script-records" caption="Script Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              a Realm Record or *undefined*
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              a Parse Node
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              a List of Records with fields [[Specifier]] (a <del>String</del><ins>ModuleSpecifier Record</ins>) and [[Module]] (a Module Record)
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <ins>[[VisibleModuleDeclarations]]</ins>
            </td>
            <td>
              <ins>a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)</ins>
            </td>
            <td>
              <ins>All the |ModuleDeclaration| declarations that are accessible from this script. It does not contain two different records with the same [[Name]].</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation" number="5">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript source text,
          _realm_: a Realm Record or *undefined*,
          _hostDefined_: anything,
        ): a Script Record or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Script Record based upon the result of parsing _sourceText_ as a |Script|.</dd>
      </dl>

      <emu-alg>
        1. Let _script_ be ParseText(_sourceText_, |Script|).
        1. If _script_ is a List of errors, return _script_.
        1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: &laquo; &raquo;, <ins>[[VisibleModuleDeclarations]]: &laquo; &raquo;,</ins> [[HostDefined]]: _hostDefined_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" number="7">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: a |Script| Parse Node,
          _env_: a Global Environment Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_script_ is the |Script| for which the execution context is being established. _env_ is the global environment in which bindings are to be created.</dd>
      </dl>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-globaldeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.
        1. Let _varNames_ be the VarDeclaredNames of _script_.
        1. For each element _name_ of _lexNames_, do
          1. If _env_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
          1. Let _hasRestrictedGlobal_ be ? _env_.HasRestrictedGlobalProperty(_name_).
          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.
        1. For each element _name_ of _varNames_, do
          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.
        1. Let _functionsToInitialize_ be a new empty List.
        1. Let _declaredFunctionNames_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, in reverse List order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _fn_ is not an element of _declaredFunctionNames_, then
              1. Let _fnDefinable_ be ? _env_.CanDeclareGlobalFunction(_fn_).
              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
              1. Append _fn_ to _declaredFunctionNames_.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _declaredVarNames_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, do
          1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
            1. For each String _vn_ of the BoundNames of _d_, do
              1. If _vn_ is not an element of _declaredFunctionNames_, then
                1. Let _vnDefinable_ be ? _env_.CanDeclareGlobalVar(_vn_).
                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                1. If _vn_ is not an element of _declaredVarNames_, then
                  1. Append _vn_ to _declaredVarNames_.
        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-globaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.
        1. <ins>Let _modulesToInitialize_ be a new empty List.</ins>
        1. Let _privateEnv_ be *null*.
        1. For each element _d_ of _lexDeclarations_, do
          1. NOTE: Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*).
            1. Else,
              1. Perform ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*).
            1. <ins>If _d_ is a |ModuleDeclaration|, then</ins>
              1. <ins>Append _d_ to _modulesToInitialize_.</ins>
        1. <ins>For each Parse Node _m_ of _modulesToInitialize_, do</ins>
            1. <ins>Let _mn_ be the sole element of the BoundNames of _m_.</ins>
            1. <ins>Let _mo_ be InstantiateModuleDeclaration of _m_.</ins>
            1. <ins>Perform ! _env_.InitializeBinding(_mn_, _mo_).</ins>
        1. For each Parse Node _f_ of _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _env_ and _privateEnv_.
          1. Perform ? <emu-meta effects="user-code">_env_.CreateGlobalFunctionBinding</emu-meta>(_fn_, _fo_, *false*).
        1. For each String _vn_ of _declaredVarNames_, do
          1. Perform ? <emu-meta effects="user-code">_env_.CreateGlobalVarBinding</emu-meta>(_vn_, *false*).
        1. Return ~unused~.
      </emu-alg>
      <emu-note>
        <p>Early errors specified in <emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref> prevent name conflicts between function/var declarations and let/const/class<ins>/module</ins> declarations as well as redeclaration of let/const/class<ins>/module</ins> bindings for declaration contained within a single |Script|. However, such conflicts and redeclarations that span more than one |Script| are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the global object is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an abrupt completion and some global declarations not being instantiated. If this occurs, the code for the |Script| is not evaluated.</p>
        <p>Unlike explicit var or function declarations, properties that are directly created on the global object result in global bindings that may be shadowed by let/const/class<ins>/module</ins> declarations.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        <ins>ModuleDeclaration</ins>
        StatementListItem[~Yield, +Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo" number="3">
        <h1>Static Semantics: ModuleRequests ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-grammar>ModuleSpecifier : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the <del>SV of |StringLiteral|</del><ins>ModuleSpecifier Record { [[Name]]: the SV of |StringLiteral|, [[Type]]: ~external~ }</ins>.
        </emu-alg>
        <emu-grammar>
          <ins>ModuleSpecifier : Identifier</ins>
        </emu-grammar>
        <emu-alg>
          1. <ins>Return a List whose sole element is the ModuleSpecifier Record { [[Name]]: the StringValue of |Identifier|, [[Type]]: ~internal~ }</ins>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>

        <emu-table id="table-abstract-methods-of-module-records" caption="Abstract Methods of Module Records" oldids="table-37">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <ins>GetExportedModule(_name_)</ins>
              </td>
              <td>
                <p><ins>Return the Module Record for the module exported by this module as _name_. If this module is a Cyclic Module Record, it can also return an ImportedModule Record representing a potential module which has been re-exported by a transitive dependency. It throws an error if there is no potential module export corresponding to _name_.</ins></p>

                <p><ins>Unless otherwise specified, the default implementation of this method is:</ins></p>
                <emu-alg>
                  1. <ins>Throw a *TypeError* exception.</ins>
                </emu-alg>
              </td>
            </tr>
            <tr>
              <td>
                LoadRequestedModules( [ _hostDefined_ ] )
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records" number="5">
        <h1>Cyclic Module Records</h1>

        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of <del>Strings</del><ins>ModuleSpecifier Records</ins>
              </td>
              <td>
                A List of <ins>Records representing</ins> all the |ModuleSpecifier| strings <ins>or identifiers</ins> used by the module represented by this record to request the importation of a module. The List is in source text occurrence order.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                a List of Records with fields [[Specifier]] (a <del>String</del><ins>ModuleSpecifier Record</ins>) and [[Module]] (a Module Record)
              </td>
              <td>
                A map from the specifier strings used by the module represented by this record to request the importation of a module to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins>LoadInternalModule( _name_ )</ins>
              </td>
              <td>
                <p><ins>Loads the internal module with the given name and returns a Module Record or, if the internal module could be imported from another module, an ImportedModule Record. It throws if an internal module named _name_ does ot exist.</ins></p>

                <p><ins>Unless otherwise specified, the default implementation of this method is:</ins></p>
                <emu-alg>
                  1. <ins>Throw a *TypeError* exception.</ins>
                </emu-alg>
              </td>
            </tr>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <p><ins>A <dfn id="modulespecifier-record" variants="ModuleSpecifier Records">ModuleSpecifier Record</dfn> represents the requet to import a module. Each ModuleSpecifier Record has the fields defined in <emu-xref href="#table-modulespecifier-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-modulespecifier-record-fields" caption="ModuleSpecifier Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[Name]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>The name of the imported module. For example, it's the string `"foo"` in `import "foo";`</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[Type]]</ins>
              </td>
              <td>
                <ins>~internal~ or ~external~</ins>
              </td>
              <td>
                <ins>Whether the module is an internal module, that should be declared nested inside another module, or an external module, that should be loaded using the HostLoadImportedModule abstract operation.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>An <dfn id="importedmodule-record" variants="ImportedModule Records">ImportedModule Record</dfn> represents a module which is imported from another module. Each ImportedModule Record has the fields defined in <emu-xref href="#table-importedmodule-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-importedmodule-record-fields" caption="ImportedModule Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[Specifier]]</ins>
              </td>
              <td>
                <ins>a ModuleSpecifier Record</ins>
              </td>
              <td>
                <ins>The specifier of the module this module is imported from.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ImportName]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>The name of the imported module.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <p>A <dfn id="moduleloadstate-record" variants="ModuleLoadState Records">ModuleLoadState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each ModuleLoadState Record has the fields defined in <emu-xref href="#table-moduleloadstate-record-fields"></emu-xref>:</p>
        <emu-table id="table-moduleloadstate-record-fields" caption="ModuleLoadState Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Action]]
              </td>
              <td>
                ~graph-loading~ or ~dynamic-import~
              </td>
              <td>
                The action that caused the call to HostLoadImportedModule. It is ~graph-loading~ when loading the dependencies of a module; it is ~dynamic-import~ when loading a module that was requested by an `import()` call.
              </td>
            </tr>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                a PromiseCapability Record
              </td>
              <td>
                The promise to resolve when the loading process finishes.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                This field is only used if [[Action]] is ~graph-loading~. It is true if the loading process has not finished yet, neither successfully nor with an error.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModules]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                This field is only used if [[Action]] is ~graph-loading~. It tracks the number of pending HostLoadImportedModule calls.
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                This field is only used if [[Action]] is ~graph-loading~. It is a list of the Cyclic Module Records that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[BlockedInternalImports]]</ins>
              </td>
              <td>
                <ins>a List of BlockedInternalImport Records</ins>
              </td>
              <td>
                <p><ins>The imports that cannot be loaded yet, because they import from an internal module which is itself imported from a module which hasn't been loaded yet.</ins></p>
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is *undefined*)
              </td>
              <td>
                It contains host-defined data to pass from the LoadRequestedModules caller to HostLoadImportedModule.
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>A <dfn id="blockedinternalimport-record" variants="BlockedInternalImport Records">BlockedInternalImport Record</dfn> represents an import from an internal module that cannot be handled, because the internal module is imported from another module that hasn't been loaded yet. Each BlockedInternalImport Record has the fields defined in <emu-xref href="#table-blockedinternalimport-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-blockedinternalimport-record-fields" caption="BlockedInternalImport Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[BlockerReferrer]]</ins>
              </td>
              <td>
                <ins>a Module Record</ins>
              </td>
              <td rowspan="2">
                <ins>[[BlockerReferrer]] and [[BlockerSpecifier]] together indicate the module that is currently preventing the internal module from being imported.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[BlockedSpecifier]]</ins>
              </td>
              <td>
                <ins>a ModuleSpecifier Record</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ImportName]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>It is the name of the expected module exported by ([[BlockerReferrer]], [[BlockerSpecifier]]).</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[BlockedReferrer]]</ins>
              </td>
              <td>
                <ins>a Cyclic Module Record</ins>
              </td>
              <td>
                <ins>It is the module that is currently blocked from importing the internal module.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[LocalName]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>It is the local alias, in [[BlockedReferrer]], of the imported module.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>To better understand the contents of BlockedInternalImport Records, consider the three modules defined in <emu-xref href="#table-blockedinternalimport-example"></emu-xref>:</ins></p>
        <emu-table id="table-blockedinternalimport-example" caption="BlockedInternalImport Record Example">
          <table>
            <tr>
              <th>
                Module
              </th>
              <th>
                Source
              </th>
            </tr>
            <tr>
              <td>
                <ins>_A_</ins>
              </td>
              <td>
                <pre><code class="javascript">import { mod as module } from "B";</code><code class="javascript">import { value } from module;</code></pre>
              </td>
            </tr>
            <tr>
              <td>
                <ins>_B_</ins>
              </td>
              <td>
                <pre><code class="javascript">export { myModule as mod } from "C";</code></pre>
              </td>
            </tr>
            <tr>
              <td>
                <ins>_C_</ins>
              </td>
              <td>
                <pre><code class="javascript">export module myModule {</code><code class="javascript" style="padding-left:4ex">export const value = 1;</code><code class="javascript">}</code></pre>
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>Assume that the loading process of external modules is asynchronous. When loading the dependencies of _A_, <code>module</code> cannot be resolved yet and it will be represented by the BlockedInternalImport Record { [[BlockerReferrer]]: _A_, [[BlockerSpecifier]]: the ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: "B" }, [[ImportName]]: <code>"mod"</code>, [[BlockedReferrer]]: _A_,[[LocalName]]: <code>"module"</code> }.</ins></p>

        <p><ins>When _B_ is loaded, <code>module</code> cannot be imported yet, because <code>mod</code> is not defined in _B_ but in one of its dependencies: the above BlockedInternalImport Record will be replaced by the BlockedInternalImport Record { [[BlockerReferrer]]: _B_, [[BlockerSpecifier]]: the ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: "C" }, [[ImportName]]: <code>"myModule"</code>, [[BlockedReferrer]]: _A_, [[LocalName]]: <code>"module"</code> }.</ins></p>

        <p><ins>Finally, after _C_ has finished loading, it's possible to load the <code>module</code> internal module. This logic is handled in the below InnerModuleLoading and ProcessBlockedInternalRequests algorithms.</ins></p>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything
            ): a Promise object
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Cyclic Module Record</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a ModuleLoadState Record whose [[Action]] is ~graph-loading~,
                _module_: a Module Record,
                <ins>optional _referrer_: a Cyclic Module Record,</ins>
                <ins>optional _specifier_: a ModuleSpecifier Record,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. <ins>If _referrer_ has been provided, then</ins>
                1. <ins>Assert: _specifier_ has been provided.</ins>
                1. <ins>Perform ProcessBlockedInternalRequests(_state_, _referrer_, _specifier_, _module_).</ins>
                1. <ins>If _state_.[[IsLoading]] is *false*, return.</ins>
              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the length of _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] + _requestedModulesCount_.
                1. For each ModuleSpecifier Record _required_ of _module_.[[RequestedModules]], do
                  1. <del>If _state_.[[IsLoading]] is *true*, then:</del>
                  1. If _module_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _required_, then
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], <ins>_module_, _required_</ins>).
                  1. <ins>Else if _required_.[[Type]] is ~internal~, then</ins>
                    1. <ins>Let _internalCompletion_ be Completion(_module_.LoadInternalModule(_required_.[[Name]])).</ins>
                    1. <ins>If AbortModuleLoading(_state_, _internalCompletion_) is *true*, return.</ins>
                    1. <ins>Let _internal_ be _internalCompletion_.[[Value]].</ins>
                    1. <ins>If _internal_ is a Module Record, then</ins>
                      1. <ins>Append Record { [[Specifier]]: _required_, [[Module]]: _internal_ } to _module_.[[LoadedModules]].</ins>
                      1. <ins>Perform InnerModuleLoading(_state_, _internal_, _module_, _required_).</ins>
                    1. <ins>Else,</ins>
                      1. <ins>Assert: _internal_ is an ImportedModule Record.</ins>
                      1. <ins>Append the Record { [[BlockerReferrer]]: _module_, [[BlockerSpecifier]]: _internal_.[[Specifier]], [[ImportName]]: _internal_.[[ImportName]], [[BlockedReferrer]]: _module_, [[LocalName]]: _required_.[[Name]] } to _state_.[[BlockedInternalImports]].</ins>
                  1. Else,
                    1. <ins>Assert: _required_.[[Type]] is ~external~.</ins>
                    1. Perform HostLoadImportedModule(_module_, <del>_required_</del><ins>_required_.[[Name]]</ins>, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call ContinueModuleLoading.
                  1. <ins>If _state_.[[IsLoading]] is *false*, return.</ins>
              1. <del>If _state_.[[IsLoading]] is *false*, return.</del>
              1. Assert: _state_.[[PendingModules]] &ge; 1.
              1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] - 1.
              1. If _state_.[[PendingModules]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ in _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a ModuleLoadState Record whose [[Action]] is ~graph-loading~,
                <ins>_referrer_: a Cyclic Module Record,</ins>
                <ins>_specifier_: a ModuleSpecifier Record,</ins>
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return.
              1. <ins>If AbortModuleLoading(_state_, _moduleCompletion_) is *true*, return.</ins>
              1. <ins>Assert: _moduleCompletion_ is a normal completion.</ins>
              1. <del>If _moduleCompletion_ is a normal completion, then:</del>
              1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]], <ins>_referrer_, _specifier_</ins>).
              1. <del>Else,</del>
                1. <del>Set _state_.[[IsLoading]] to *false*.</del>
                1. <del>Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).</del>
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ProcessBlockedInternalRequests" type="abstract operation">
            <h1>
              <ins>
                ProcessBlockedInternalRequests (
                  _state_: a ModuleLoadState Record whose [[Action]] is ~graph-loading~,
                  _referrer_: a Cyclic Module Record,
                  _specifier_: a ModuleSpecifier Record,
                  _module_: a Module Record,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd></dd>
            </dl>

            <emu-alg>
              1. For each Record _dep_ of _state_.[[BlockedInternalImports]] such that _dep_.[[BlockerReferrer]] is _referrer_ and _dep_.[[BlockerSpecifier]] is _specifier_, do
                1. Let _exportedCompletion_ be Completion(_module_.GetExportedModule(_dep_.[[ImportName]])).
                1. If AbortModuleLoading(_state_, _exportedCompletion_) is *true*, return.
                1. Assert: _exportedCompletion_ is a normal completion.
                1. Let _exported_ be _exportedCompletion_.[[Value]].
                1. If _exported_ is a Module Record, then
                  1. Let _internalSpecifier_ be the ModuleSpecifier Record { [[Type]]: ~internal~, [[Name]]: _dep_.[[LocalName]] }.
                  1. Append the Record { [[Specifier]]: _internalSpecifier_, [[Module]]: _exported_ } to _dep_.[[BlockedReferrer]].[[LoadedModules]].
                  1. Perform InnerModuleLoading(_state_, _exported_, _module_, _internalSpecifier_).
                  1. If _state_.[[IsLoading]] is *false*, return.
                1. Else,
                  1. Assert: _exported_ is an ImportedModule Record.
                  1. Remove _dep_ from _state_.[[BlockedInternalImports]].
                  1. Append the Record { [[BlockerReferrer]]: _module_, [[BlockerSpecifier]]: _exported_.[[Specifier]], [[ImportName]]: _exported_.[[ImportName]], [[BlockedReferrer]]: _dep_.[[BlockedReferrer]], [[LocalName]]: _dep_.[[LocalName]] } to _state_.[[BlockedInternalImports]].
            </emu-alg>

            <emu-note type="editor">
              TODO: Handle import cycles.
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-AbortModuleLoading" type="abstract operation">
            <h1>
              <ins>
                AbortModuleLoading (
                  _state_: a ModuleLoadState Record whose [[Action]] is ~graph-loading~,
                  _completion_: a normal completion or a throw completion,
                ): a Boolean
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd></dd>
            </dl>

            <emu-alg>
              1. If _completion_ is a normal completion, return *false*.
              1. Set _state_.[[IsLoading]] to *false*.
              1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _completion_.[[Value]] &raquo;).
              1. Return *true*.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records" number="6">
        <h1>Source Text Module Records</h1>

        <p>In addition to the fields defined in <emu-xref href="#table-cyclic-module-fields"></emu-xref>, Source Text Module Records have the additional fields listed in <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref>. Each of these fields is initially set in ParseModule.</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="Additional Fields of Source Text Module Records" oldids="table-38">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                a Parse Node
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                an ECMAScript execution context
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                an Object
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                a List of ImportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <ins>[[VisibleModuleDeclarations]]</ins>
              </td>
              <td>
                <ins>a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)</ins>
              </td>
              <td>
                <ins>All the |ModuleDeclaration| declarations that are accessible from this module, either defined in this module or in a parent module. It does not contain two different records with the same [[Name]].</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <p>The following definitions specify the required concrete methods and other abstract operations for Source Text Module Records</p>

        <emu-clause id="sec-parsemodule" type="abstract operation" number="1">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: a Realm Record,
              _hostDefined_: anything,
              optional _outerModuleDeclarations_: a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. <ins>Let _outerModuleDeclarationNames_ be a new empty List.</ins>
            1. <ins>If _outerModuleDeclarations_ is present, then</ins>
              1. <ins>For each Record _decl_ in _outerModuleDeclarations_, do</ins>
                1. <ins>Append _decl_.[[Name]] to _outerModuleDeclarationNames_.</ins>
            1. <ins>If ContainsUndefinedModuleReference of _body_ with argument _outerModuleDeclarationNames_ is *true*, return &laquo; a new *TypeError* &raquo;.</ins>
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. Let _importEntries_ be ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ of _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is ~namespace-object~, then
                    1. NOTE: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. NOTE: This is a re-export of a single name.
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                1. Assert: _ee_.[[ExportName]] is *null*.
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. Let _async_ be _body_ Contains `await`.
            1. <ins>Let _visibleModuleDeclarations_ be a new empty List.</ins>
            1. <ins>Let _rawModuleDeclarations_ be the RawModuleDeclarations of _body_.</ins>
            1. <ins>For each Record _rawDecl_ of _rawModuleDeclarations_, do</ins>
              1. <ins>Append the Record { [[Name]]: _rawDecl_.[[Name]], [[Module]]: ~empty~ } to _visibleModuleDeclarations_.</ins>
              1. <ins>NOTE: The [[Module]] field of this Record will be set to a Module Record before the end of this ParseModule operation. The ~empty~ value is never observable outside of ParseModule.</ins>
            1. <ins>If _outerModuleDeclarations_ is present, then</ins>
              1. <ins>For each Record _m_ of _outerModuleDeclarations_, do</ins>
                1. <ins>If _visibleModuleDeclarations_ does not contain a Record with [[Name]] equal to _m_.[[Name]], then</ins>
                  1. <ins>Append _m_ to _visibleModuleDeclarations_.</ins>
              1. <ins>TODO: Instead of copying all of them, we could just add the declarations that are imported inside this module. This would simplify structured cloning, since we wouldn't need to clone all the visible modules.</ins>
            1. <ins>For each Record _rawDecl_ of _rawModuleDeclarations_, do</ins>
              1. <ins>Let _rec_ be the Record in _visibleModuleDeclarations_ with [[Name]] equal to _rawDecl_.[[Name]].</ins>
              1. <ins>Assert: _rec_ exists and is unique.</ins>
              1. <ins>Let _moduleRecord_ be ParseModule(_rawDecl_.[[Body]], _realm_, _hostDefined_, _visibleModuleDeclarations_).</ins>
              1. <ins>Assert: _moduleRecord_ is a Module Record, because parsing errors would have been reported while parsing the outer module.</ins>
              1. <ins>Set _rec_.[[Module]] to _moduleRecord_.</ins>
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: &laquo; &raquo;, [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: a new empty List, <ins>[[VisibleModuleDeclarations]]: _visibleModuleDeclarations_,</ins> [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method" number="4">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be ? _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleSpecifier]]).
              1. Assert: _importedModule_ is not ~empty~, because imported module requests are a subset of _module_.[[RequestedModules]], and these have been resolved earlier in this algorithm.
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be ? GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. Else,
                1. Let _resolution_ be ? _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be ? GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _dn_ is not an element of _declaredVarNames_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
                1. <ins>Else if _d_ is a |ModuleDeclaration|, then</ins>
                  1. <ins>Let _mo_ be InstantiateModuleDeclaration of _d_.</ins>
                  1. <ins>Perform ! _env_.InitializeBinding(_dn_, _mo_).</ins>
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method" number="6">
          <h1>
            <ins>
              LoadInternalModule (
                _name_: a String,
              ): a normal completion containing a Module Record or a ImportedModule Record, or a throw completion
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ImportEntry Record _entry_ of _module_.[[ImportEntries]], do
              1. If _entry_.[[LocalName]] is _name_, then
                1. If _entry_.[[ImportName]] is ~namespace-object~, throw a *TypeError* exception.
                1. Return the ImportedModule Record { [[Specifier]]: _entry_.[[ModuleRequest]], [[ImportName]]: _entry_.[[ImportName]] }.
            1. For each Record _r_ of _module_.[[VisibleModuleDeclarations]], do
              1. If _r_.[[Name]] is equal to _name_, then
                1. Return _r_.[[Module]].
            1. Throw a new *TypeError* exception.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-GetExportedModule" type="concrete method">
          <h1>
            <ins>
              GetExportedModule (
                _name_: a String,
              ): either a normal completion containing a Module Record or a ImportedModule Record, or a throw completion
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntries Record _entry_ of _module_.[[LocalExportEntries]], do
              1. If _entry_.[[ExportName]] is _name_, then
                1. If _entry_.[[ModuleRequest]] is *null*, then
                  1. Assert: _entry_.[[LocalName]] is a String.
                  1. For each Record _decl_ of _module_.[[VisibleModuleDeclarations]], do
                    1. If _decl_.[[Name]] is _entry_.[[LocalName]], then
                      1. Return _decl_.[[Module]].
                  1. Throw a new *TypeError* exception.
                1. Else if _entry_.[[ImportName]] is ~all-but-default~, then
                  1. Throw a new *TypeError* exception.
                1. Else if _entry_.[[ImportName]] is ~all~, then
                  1. TODO: Study how we can support this case, if needed.
                  1. Throw a new *TypeError* exception.
                1. Else,
                  1. Assert: _entry_.[[ImportName]] is a String.
                  1. Return the ImportedModule Record { [[Specifier]]: _entry_.[[ModuleRequest]], [[ImportName]]: _entry_.[[ImportName]] }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" number="8">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _specifier_: a String,
            _state_: a ModuleLoadState Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. <ins>Let _specifierRecord_ be the ModuleSpecifier Record { [[Name]]: _specifier_, [[Type]]: ~external~ }.</ins>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is <del>_specifier_</del><ins>_specifierRecord_</ins>, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: <del>_specifier_</del><ins>_specifierRecord_</ins>, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _state_.[[Action]] is ~graph-loading~, then
            1. Perform ContinueModuleLoading(_state_, <ins>_referrer_, _specifierRecord_,</ins> _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_state_, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>Imports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause `;`
          `import` ModuleSpecifier `;`

        FromClause :
          `from` ModuleSpecifier

        ModuleSpecifier :
          StringLiteral
          <ins>Identifier</ins>
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>Exports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          <ins>`export` ModuleDeclaration</ins>
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`
      </emu-grammar>

      <emu-note type="editor">
        TODO: Consider <code>export default</code> |ModuleDeclaration|.
      </emu-note>

      <emu-clause id="sec-static-semantics-exportedbindings" type="sdo" number="2">
        <h1>Static Semantics: ExportedBindings ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-grammar><ins>ExportDeclaration : `export` ModuleDeclaration</ins></emu-grammar>
        <emu-alg>
          1. <ins>Return the BoundNames of |ModuleDeclaration|.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" type="sdo">
        <h1>Static Semantics: ExportedNames ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-grammar><ins>ExportDeclaration : `export` ModuleDeclaration</ins></emu-grammar>
        <emu-alg>
          1. <ins>Return the BoundNames of |ModuleDeclaration|.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" oldids="sec-module-semantics-static-semantics-exportentries,sec-exports-static-semantics-exportentries" type="sdo">
        <h1>Static Semantics: ExportEntries ( ): a List of ExportEntry Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar><ins>ExportDeclaration : `export` ModuleDeclaration</ins></emu-grammar>
        <emu-alg>
          1. <ins>Let _names_ be BoundNames of |ModuleDeclaration|.</ins>
          1. <ins>Let _localName_ be the sole element of _names_.</ins>
          1. <ins>Return a List whose sole element is the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: _localName_ }.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo" number="7">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar><ins>ExportDeclaration : `export` ModuleDeclaration</ins></emu-grammar>
        <emu-alg>
          1. <ins>Return ? Evaluation of |ModuleDeclaration|.</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

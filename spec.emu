<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Module Declarations
stage: 2
contributors: Daniel Ehrenberg, Nicol√≤ Ribaudo
</pre>

<emu-clause id="sec-module-declarations">
  <h1><ins>Module Declarations</ins></h1>

  <emu-note type="editor">
    <p>This proposal builds on top of <a href="https://tc39.es/proposal-js-module-blocks/">the Module Expressions proposal</a>, which introduces the following production:</p>
    <emu-grammar type="definition">
      ModuleExpression :
        `module` [no LineTerminator here] `{` ModuleBody? `}`
    </emu-grammar>
  </emu-note>

  <h2>Syntax</h2>
  <emu-grammar type="definition">
    ModuleDeclaration[Default] :
      `module` [no LineTerminator here] Identifier `{` ModuleBody? `}`
      [+Default] `module` [no LineTerminator here] `{` ModuleBody? `}`
  </emu-grammar>

  <emu-clause id="sec-module-declarations-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>

    <emu-grammar>
      ModuleDeclaration :
        `module` Identifier `{` ModuleBody? `}`
        `module` `{` ModuleBody? `}`
    </emu-grammar>
    <emu-alg>
      1. Return ~empty~.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations" number="8">
  <h1>Syntax-Directed Operations</h1>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis" number="2">
    <h1>Scope Analysis</h1>

    <emu-clause id="sec-static-semantics-boundnames" type="sdo" number="1">
      <h1>Static Semantics: BoundNames ( ): a List of Strings</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        <ins>ModuleDeclaration : `module` Identifier `{` ModuleBody? `}`</ins>
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of Identifier.
      </emu-alg>
      <emu-grammar>
        <ins>ModuleDeclaration : `module` `{` ModuleBody? `}`</ins>
      </emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
      <emu-grammar>
        <ins>ExportDeclaration : `export` `default` ModuleDeclaration</ins>
      </emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |ModuleDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" type="sdo" number="3">
      <h1>Static Semantics: IsConstantDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        <ins>
          ModuleDeclaration :
            `module` Identifier `{` ModuleBody? `}`
            `module` `{` ModuleBody? `}`
        </ins>
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" type="sdo" number="5">
      <h1>Static Semantics: LexicallyScopedDeclarations ( ): a List of Parse Nodes</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        <ins>Declaration : ModuleDeclaration</ins>
      </emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is |ModuleDeclaration|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-containsundefinedmodulereference" type="sdo" number="12">
      <h1>
        <ins>
          Static Semantics: ContainsUndefinedModuleReference (
            _declaredModules_: a List of Strings,
          ): a Boolean
        </ins>
      </h1>
      <dl class="header">
      </dl>
      <p>Unless explicitly specified otherwise, all nonterminals have an implicit definition for ContainsUndefinedModuleReference with argument _declaredModules_.The implicit definition applies ContainsUndefinedModuleReference with argument _declaredModules_ to the nonterminal's inner nonterminals, and returns *true* if it's *true* for any of them. For example, ContainsUndefinedModuleReference of |ExponentiationExpression| is implicitly defined as follows:</p>
      <emu-grammar example>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg example>
        1. Let _hasUndefinedRef_ be ContainsUndefinedModuleReference of |UpdateExpression| with argument _declaredModules_.
        1. If _hasUndefinedRef_ is *true*, return *true*.
        1. Return ContainsUndefinedModuleReference of |ExponentiationExpression| with argument _declaredModules_.
      </emu-alg>

      <p>The following productions have a different definition of ContainsUndefinedModuleReference:</p>

      <emu-grammar>
        ModuleSpecifier : Identifier
      </emu-grammar>
      <emu-alg>
        1. Let _reference_ be the StringValue of |Identifier|.
        1. If _reference_ is in _declaredModules_, return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-grammar>
        ModuleBody : ModuleItemList
      </emu-grammar>
      <emu-alg>
        1. Let _localDeclaredModules_ be DeclaredModuleNames of |ModuleItemList|.
        1. Let _lexNames_ be the LexicallyDeclaredNames of |ModuleItemList|.
        1. Let _varNames_ be the VarDeclaredNames of |ModuleItemList|.
        1. Let _visibleDeclaredModules_ be a new List containing the elements of _declaredModules_ that are not in _lexNames_ or _varNames_.
        1. Append all the elements of _localDeclaredModules_ to _visibleDeclaredModules_.
        1. Return ContainsUndefinedModuleReference of |ModuleItemList| with argument _visibleDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        ScriptBody : StatementList
      </emu-grammar>
      <emu-alg>
        1. Assert: _declaredModules_ is an empty List.
        1. Let _localDeclaredModules_ be DeclaredModuleNames of |StatementList|.
        1. Return ContainsUndefinedModuleReference of |StatementList| with argument _localDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        FunctionStatementList : StatementList
        ClassStaticBlockStatementList : StatementList
        Block : `{` StatementList `}`
      </emu-grammar>
      <emu-alg>
        1. Let _lexNames_ be the LexicallyDeclaredNames of |StatementList|.
        1. Let _varNames_ be the VarDeclaredNames of |StatementList|.
        1. Let _localDeclaredModules_ be the DeclaredModuleNames of |StatementList|.
        1. Let _visibleDeclaredModules_ be a new List containing the elements of _declaredModules_ that are not in _lexNames_ or _varNames_.
        1. Append each element of _localDeclaredModules_ to _visibleDeclaredModules_.
        1. Return ContainsUndefinedModuleReference of |StatementList| with argument _visibleDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        FunctionStatementList : [empty]
        ClassStaticBlockStatementList : [empty]
        Block : `{` `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>

      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |BindingIdentifier| is present, return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |FormalParameters|, |FunctionBody|, |BindingIdentifier|).
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |FormalParameters|, |FunctionBody|).
      </emu-alg>

      <emu-grammar>
        MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |FunctionBody|).
      </emu-alg>

      <emu-grammar>
        MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |PropertySetParameterList|, |FunctionBody|).
      </emu-alg>

      <emu-grammar>
        GeneratorDeclaration :
          `function` BindingIdentifier `*` `(` UniqueFormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` BindingIdentifier? `*` `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |BindingIdentifier| is present, return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |GeneratorBody|, |BindingIdentifier|).
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |GeneratorBody|).
      </emu-alg>

      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |BindingIdentifier| is present, return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |AsyncFunctionBody|, |BindingIdentifier|).
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |AsyncFunctionBody|).
      </emu-alg>

      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` BindingIdentifier `*` `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` BindingIdentifier? `*` `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |BindingIdentifier| is present, return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |AsyncGeneratorBody|, |BindingIdentifier|).
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |UniqueFormalParameters|, |AsyncGeneratorBody|).
      </emu-alg>

      <emu-grammar>
        ArrowFunction : ArrowParameters `=>` ConciseBody
      </emu-grammar>
      <emu-alg>
        1. If |ArrowParameters| is |BindingIdentifier|, let _params_ be |BindingIdentifier|.
        1. Else,
          1. Let _cover_ be the |CoverParenthesizedExpressionAndArrowParameterList| of |ArrowParameters|.
          1. Let _params_ be the |ArrowFormalParameters| that is covered by _cover_.
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, _params_, |ConciseBody|).
      </emu-alg>

      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. Let _params_ be the |BindingIdentifier| of |AsyncArrowBindingIdentifier|.
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, _params_, |AsyncConciseBody|).
      </emu-alg>

      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. Let _params_ be the |ArrowFormalParameters| of _head_.
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, _params_, |AsyncConciseBody|).
      </emu-alg>

      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. Let _visibleDeclaredModules_ be _declaredModules_.
        1. If |BindingIdentifier| is present, then
          1. Let _id_ be the StringValue of |BindingIdentifier|.
          1. Set _visibleDeclaredModules_ to a new List containing the elements of _declaredModules_ that are not equal to _id_.
        1. Return ContainsUndefinedModuleReference of |ClassTail| with argument _visibleDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        Catch : `catch` `(` CatchParameter `)` Block
      </emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedModuleReferenceInFunction(_declaredModules_, |CatchParameter|, |Block|).
      </emu-alg>

      <emu-clause id="sec-ContainsUndefinedModuleReferenceInFunction" type="abstract operation">
        <h1>
          ContainsUndefinedModuleReferenceInFunction (
            _declaredModules_: a List of Strings,
            _params_: a Parse Node,
            _body_: a Parse Node,
            optional _binding_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _boundNames_ be the BoundNames of _params_.
          1. If _binding_ is present, append the StringValue of _binding_ to _boundNames_.
          1. Let _visibleDeclaredModules_ be a new List containing the elements of _declaredModules_ that are not in _boundNames_.
          1. If ContainsUndefinedModuleReference of _params_ with argument _visibleDeclaredModules_ is *true*, return *true*.
          1. Let _localDeclaredModules_ be the DeclaredModuleNames of |StatementList|.
          1. Append each element of _localDeclaredModules_ to _visibleDeclaredModules_.
          1. Return ContainsUndefinedModuleReference of _body_ with argument _visibleDeclaredModules_ is *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-declaredmodulenames" type="sdo">
      <h1>
        <ins>
          Static Semantics: DeclaredModuleNames ( ): a List of Strings
        </ins>
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ModuleItemList : ModuleItemList ModuleItem
      </emu-grammar>
      <emu-alg>
        1. Let _names1_ be DeclaredModuleNames of |ModuleItemList|.
        1. Let _names2_ be DeclaredModuleNames of |ModuleItem|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>

      <emu-grammar>
        StatementList : StatementList StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Let _names1_ be DeclaredModuleNames of |StatementList|.
        1. Let _names2_ be DeclaredModuleNames of |StatementListItem|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>

      <emu-grammar>
        StatementListItem : Statement
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>

      <emu-grammar>
        Declaration :
          HoistableDeclaration
          LexicalDeclaration
          ClassDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>

      <emu-grammar>
        Declaration : ModuleDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return BoundNames of |ModuleDeclaration|.
      </emu-alg>

      <emu-grammar>
        ModuleItem : ImportDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportDeclaration|.
      </emu-alg>
      <emu-note>
        DeclaredModuleNames includes all the imported bindings, so that using them as import specifiers doesn't throw when parsing the module. However, they will be validated when linking by LoadInternalModule.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toplevelmoduledeclarations" type="sdo">
      <h1>
        <ins>
          Static Semantics: TopLevelModuleDeclarations ( ): a List of |ModuleDeclaration| Parse Node
        </ins>
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ModuleItemList : ModuleItemList ModuleItem
      </emu-grammar>
      <emu-alg>
        1. Let _decls1_ be TopLevelModuleDeclarations of |ModuleItemList|.
        1. Let _decls2_ be TopLevelModuleDeclarations of |ModuleItem|.
        1. Return the list-concatenation of _decls1_ and _decls2_.
      </emu-alg>

      <emu-grammar>
        ModuleItem : Statement
        ModuleItem : ImportDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>

      <emu-grammar>
        Declaration : ModuleDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new List whose sole element is |ModuleDeclaration|.
      </emu-alg>

      <emu-grammar>
        Declaration :
          HoistableDeclaration
          LexicalDeclaration
          ClassDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>

      <emu-grammar>
        ExportDeclaration : `export` `default` ModuleDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return a new List whose sole element is |ModuleDeclaration|.
      </emu-alg>

      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` VariableStatement
          `export` `default` HoistableDeclaration
          `export` `default` ClassDeclaration
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parseinnermodules" type="sdo">
      <h1>
        <ins>
          Static Semantics: ParseInnerModules (
            _declaredModules_: a List of Records,
          ): ~unused~
        </ins>
      </h1>
      <dl class="header"></dl>
      <p>Unless explicitly specified otherwise, all nonterminals have an implicit definition for ParseInnerModules with argument _declaredModules_.The implicit definition applies ParseInnerModules with argument _declaredModules_ to the nonterminal's inner nonterminals. For example, ContainsUndefinedModuleReference of |ExponentiationExpression| is implicitly defined as follows:</p>
      <emu-grammar example>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg example>
        1. Perform ParseInnerModules of |UpdateExpression| with argument _declaredModules_.
        1. Perform ParseInnerModules of |ExponentiationExpression| with argument _declaredModules_.
      </emu-alg>

      <p>The following productions have a different definition of ContainsUndefinedModuleReference:</p>

      <emu-grammar>
        ModuleSpecifier : Identifier
      </emu-grammar>
      <emu-alg>
        1. Let _reference_ be the StringValue of |Identifier|.
        1. If _reference_ is in _declaredModules_, return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-grammar>
        ModuleBody : ModuleItemList
      </emu-grammar>
      <emu-alg>
        1. Let _localDeclaredModules_ be DeclaredModuleNames of |ModuleItemList|.
        1. Let _lexNames_ be the LexicallyDeclaredNames of |ModuleItemList|.
        1. Let _varNames_ be the VarDeclaredNames of |ModuleItemList|.
        1. Let _visibleDeclaredModules_ be a new List containing the elements of _declaredModules_ that are not in _lexNames_ or _varNames_.
        1. Append all the elements of _localDeclaredModules_ to _visibleDeclaredModules_.
        1. Return ContainsUndefinedModuleReference of |ModuleItemList| with argument _visibleDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        ScriptBody : StatementList
      </emu-grammar>
      <emu-alg>
        1. Assert: _declaredModules_ is an empty List.
        1. Let _localDeclaredModules_ be DeclaredModuleNames of |StatementList|.
        1. Return ContainsUndefinedModuleReference of |StatementList| with argument _localDeclaredModules_.
      </emu-alg>

      <emu-grammar>
        Block : `{` `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>

      <emu-grammar>
        Block : `{` StatementList `}`
      </emu-grammar>
      <emu-alg>
        1. Let _lexNames_ be the LexicallyDeclaredNames of |StatementList|.
        1. Let _visibleDeclaredModules_ be a new List containing the elements of _declaredModules_ that are not in _lexNames_.
        1. Return ContainsUndefinedModuleReference of |StatementList| with argument _visibleDeclaredModules_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts" number="9">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>Environment Records</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn> is a specification type used to define the association of |Identifier|s to specific variables and functions, based upon the lexical nesting structure of ECMAScript code. Usually an Environment Record is associated with some specific syntactic structure of ECMAScript code such as a |FunctionDeclaration|, a |BlockStatement|, or a |Catch| clause of a |TryStatement|. Each time such code is evaluated, a new Environment Record is created to record the identifier bindings that are created by that code.</p>
    <p>Every Environment Record has an [[OuterEnv]] field, which is either *null* or a reference to an outer Environment Record. This is used to model the logical nesting of Environment Record values. The outer reference of an (inner) Environment Record is a reference to the Environment Record that logically surrounds the inner Environment Record. An outer Environment Record may, of course, have its own outer Environment Record. An Environment Record may serve as the outer environment for multiple inner Environment Records. For example, if a |FunctionDeclaration| contains two nested |FunctionDeclaration|s then the Environment Records of each of the nested functions will have as their outer Environment Record the Environment Record of the current evaluation of the surrounding function.</p>
    <p>Environment Records are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>

    <p><ins>Each Environment Record has the fields listed in <emu-xref href="#table-fields-of-environment-records"></emu-xref>.</ins></p>
    <emu-table id="table-fields-of-environment-records" caption="Fields of Environment Records">
      <table>
        <tr>
          <th>
            Field
          </th>
          <th>
            Type
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            <ins>[[OuterEnv]]</ins>
          </td>
          <td>
            <ins>an Environment Record or *null*</ins>
          </td>
          <td>
          </td>
        </tr>
        <tr>
          <td>
            <ins>[[ModuleDeclarations]]</ins>
          </td>
          <td>
            <ins>a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)</ins>
          </td>
          <td>
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>Environment Record Operations</h1>
      <p>The following abstract operations are used in this specification to operate upon Environment Records:</p>

      <emu-clause id="sec-addmoduledeclaration" type="abstract operation">
        <h1>
          <ins>
            AddModuleDeclaration (
              _name_: a String,
              _module_: a Module Record,
              _env_: an Environment Record
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Append the Record { [[Name]]: _name_, [[Module]]: _module_ } to _env_.[[ModuleDeclarations]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-resolvemoduledeclaration" type="abstract operation">
        <h1>
          <ins>
            ResolveModuleDeclaration (
              _name_: a String,
              _env_: an Environment Record
            ): either a normal completion containing a Module Record, or a throw completion
          </ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _moduleDeclarations_ be _env_.[[ModuleDeclarations]].
          1. For each Record _m_ in _moduleDeclarations_, do
            1. If _m_.[[Name]] is _name_, return _m_.[[Module]].
          1. If _env_.HasBinding(_name_), throw a *ReferenceError* exception.
          1. If _env_ is a Module Environment Record or a Global Environment Record, throw a *ReferenceError* exception.
          1. Assert: _env_.[[OuterEnv]] is not *null*.
          1. Return ? ResolveModuleDeclaration(_name_, _env_.[[OuterEnv]]).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours" number="10">
  <h1>Ordinary and Exotic Objects Behaviours</h1>

  <emu-clause id="sec-ecmascript-function-objects" number="2">
    <h1>ECMAScript Function Objects</h1>

    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation" number="11">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: a function object,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing ~unused~ or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ is the function object for which the execution context is being established.</dd>
      </dl>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-functiondeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _calleeContext_ be the running execution context.
        1. Let _code_ be _func_.[[ECMAScriptCode]].
        1. Let _strict_ be _func_.[[Strict]].
        1. Let _formals_ be _func_.[[FormalParameters]].
        1. Let _parameterNames_ be the BoundNames of _formals_.
        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.
        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.
        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.
        1. Let _varNames_ be the VarDeclaredNames of _code_.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.
        1. Let _functionNames_ be a new empty List.
        1. Let _functionsToInitialize_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, in reverse List order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _fn_ is not an element of _functionNames_, then
              1. Insert _fn_ as the first element of _functionNames_.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _argumentsObjectNeeded_ be *true*.
        1. If _func_.[[ThisMode]] is ~lexical~, then
          1. NOTE: Arrow functions never have an arguments object.
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if *"arguments"* is an element of _parameterNames_, then
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if _hasParameterExpressions_ is *false*, then
          1. If *"arguments"* is an element of _functionNames_ or if *"arguments"* is an element of _lexicalNames_, then
            1. Set _argumentsObjectNeeded_ to *false*.
        1. If _strict_ is *true* or if _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single Environment Record is needed for the parameters, since calls to `eval` in strict mode code cannot create new bindings which are visible outside of the `eval`.
          1. Let _env_ be the LexicalEnvironment of _calleeContext_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.
          1. Let _calleeEnv_ be the LexicalEnvironment of _calleeContext_.
          1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).
          1. Assert: The VariableEnvironment of _calleeContext_ is _calleeEnv_.
          1. Set the LexicalEnvironment of _calleeContext_ to _env_.
        1. For each String _paramName_ of _parameterNames_, do
          1. Let _alreadyDeclared_ be ! _env_.HasBinding(_paramName_).
          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
          1. If _alreadyDeclared_ is *false*, then
            1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).
            1. If _hasDuplicates_ is *true*, then
              1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*).
        1. If _argumentsObjectNeeded_ is *true*, then
          1. If _strict_ is *true* or if _simpleParameterList_ is *false*, then
            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).
          1. Else,
            1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).
          1. If _strict_ is *true*, then
            1. Perform ! _env_.CreateImmutableBinding(*"arguments"*, *false*).
            1. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.
          1. Else,
            1. Perform ! _env_.CreateMutableBinding(*"arguments"*, *false*).
          1. Perform ! _env_.InitializeBinding(*"arguments"*, _ao_).
          1. Let _parameterBindings_ be the list-concatenation of _parameterNames_ and &laquo; *"arguments"* &raquo;.
        1. Else,
          1. Let _parameterBindings_ be _parameterNames_.
        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).
        1. If _hasDuplicates_ is *true*, then
          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and *undefined*.
        1. Else,
          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _env_.
        1. If _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.
          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.
          1. For each element _n_ of _varNames_, do
            1. If _n_ is not an element of _instantiatedVarNames_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _env_.CreateMutableBinding(_n_, *false*).
              1. Perform ! _env_.InitializeBinding(_n_, *undefined*).
          1. Let _varEnv_ be _env_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).
          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.
          1. Let _instantiatedVarNames_ be a new empty List.
          1. For each element _n_ of _varNames_, do
            1. If _n_ is not an element of _instantiatedVarNames_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).
              1. If _n_ is not an element of _parameterBindings_ or if _n_ is an element of _functionNames_, let _initialValue_ be *undefined*.
              1. Else,
                1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).
              1. Perform ! _varEnv_.InitializeBinding(_n_, _initialValue_).
              1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.
        1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-functiondeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. If _strict_ is *false*, then
          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).
          1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
        1. Else, let _lexEnv_ be _varEnv_.
        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.
        1. <ins>Let _outerModuleDeclarations_ be the outer module declarations, obtained using ResolveModuleDeclaration (TODO: define how).</ins>
        1. <ins>Let _moduleHostDefined_ be *null*.</ins>
        1. <ins>Let _currentScriptOrModule_ be GetActiveScriptOrModule().</ins>
        1. <ins>If _currentScriptOrModule_ is not *null*, set _moduleHostDefined_ to _currentScriptOrModule_.[[HostDefined]].</ins>
        1. <ins>Let _localModuleDeclarations_ be InstantiateModuleDeclarations(_code_, the current Realm Record, _moduleHostDefined_, _outerModuleDeclarations_).</ins>
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
        1. For each element _d_ of _lexDeclarations_, do
          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).
        1. Let _privateEnv_ be the PrivateEnvironment of _calleeContext_.
        1. <ins>For each Record _m_ in _localModuleDeclarations_, do</ins>
          1. <ins>Perform AddModuleDeclaration(_m_.[[Name]], _m.[[Module]], _env_).</ins>
          1. <ins>Let _mo_ be GetModuleObject(_m_.[[Module]]).</ins>
          1. <ins>Perform ! _env_.InitializeBinding(_m_.[[Name]], _mo_).</ins>
        1. For each Parse Node _f_ of _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.
          1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
        1. Return ~unused~.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> provides an extension to the above algorithm that is necessary for backwards compatibility with web browser implementations of ECMAScript that predate ECMAScript 2015.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations" number="14">
  <h1>ECMAScript Language: Statements and Declarations</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]
      <ins>ModuleDeclaration[~Default]</ins>
  </emu-grammar>

  <emu-clause id="sec-block" number="2">
    <h1>Block</h1>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation" number="3">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ is the Parse Node corresponding to the body of the block. _env_ is the Environment Record in which bindings are to be created.</dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-blockdeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. <ins>Let _outerModuleDeclarations_ be the outer module declarations, obtained using ResolveModuleDeclaration (TODO: define how).</ins>
        1. <ins>Let _moduleHostDefined_ be *null*.</ins>
        1. <ins>Let _currentScriptOrModule_ be GetActiveScriptOrModule().</ins>
        1. <ins>If _currentScriptOrModule_ is not *null*, set _moduleHostDefined_ to _currentScriptOrModule_.[[HostDefined]].</ins>
        1. <ins>Let _localModuleDeclarations_ be InstantiateModuleDeclarations(_code_, the current Realm Record, _moduleHostDefined_, _outerModuleDeclarations_).</ins>
        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. For each element _d_ of _declarations_, do
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. [id="step-blockdeclarationinstantiation-createmutablebinding"] Perform ! _env_.CreateMutableBinding(_dn_, *false*). NOTE: This step is replaced in section <emu-xref href="#sec-web-compat-blockdeclarationinstantiation"></emu-xref>.
          1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
            1. [id="step-blockdeclarationinstantiation-initializebinding"] Perform ! _env_.InitializeBinding(_fn_, _fo_). NOTE: This step is replaced in section <emu-xref href="#sec-web-compat-blockdeclarationinstantiation"></emu-xref>.
        1. <ins>For each Record _m_ in _localModuleDeclarations_, do</ins>
          1. <ins>Perform AddModuleDeclaration(_m_.[[Name]], _m.[[Module]], _env_).</ins>
          1. <ins>Let _mo_ be GetModuleObject(_m_.[[Module]]).</ins>
          1. <ins>Perform ! _env_.InitializeBinding(_m_.[[Name]], _mo_).</ins>
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>

    <emu-clause id="sec-scripts-static-semantics-early-errors" number="1">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |ScriptBody| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |ScriptBody| also occurs in the VarDeclaredNames of |ScriptBody|.
        </li>
        <li>
          <ins>It is a Syntax Error if ContainsUndefinedModuleReference of |ScriptBody| with argument a new empty List is *true*.</ins>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-script-records" number="4">
      <h1>Script Records</h1>

      <p>A <dfn id="script-record" variants="Script Records">Script Record</dfn> encapsulates information about a script being evaluated. Each script record contains the fields listed in <emu-xref href="#table-script-records"></emu-xref>.</p>

      <emu-table id="table-script-records" caption="Script Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              a Realm Record or *undefined*
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              a Parse Node
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              a List of Records with fields [[Specifier]] (a <del>String</del><ins>ModuleSpecifier Record</ins>) and [[Module]] (a Module Record)
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" number="7">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: a |Script| Parse Node,
          _env_: a Global Environment Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_script_ is the |Script| for which the execution context is being established. _env_ is the global environment in which bindings are to be created.</dd>
      </dl>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-globaldeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.
        1. Let _varNames_ be the VarDeclaredNames of _script_.
        1. For each element _name_ of _lexNames_, do
          1. If _env_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
          1. Let _hasRestrictedGlobal_ be ? _env_.HasRestrictedGlobalProperty(_name_).
          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.
        1. For each element _name_ of _varNames_, do
          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.
        1. Let _functionsToInitialize_ be a new empty List.
        1. Let _declaredFunctionNames_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, in reverse List order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _fn_ is not an element of _declaredFunctionNames_, then
              1. Let _fnDefinable_ be ? _env_.CanDeclareGlobalFunction(_fn_).
              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
              1. Append _fn_ to _declaredFunctionNames_.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _declaredVarNames_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, do
          1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
            1. For each String _vn_ of the BoundNames of _d_, do
              1. If _vn_ is not an element of _declaredFunctionNames_, then
                1. Let _vnDefinable_ be ? _env_.CanDeclareGlobalVar(_vn_).
                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                1. If _vn_ is not an element of _declaredVarNames_, then
                  1. Append _vn_ to _declaredVarNames_.
        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-globaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. <ins>Let _localModuleDeclarations_ be InstantiateModuleDeclarations(_script_, _script_.[[Realm]], _script_.[[HostDefined]], a new empty List).</ins>
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.
        1. Let _privateEnv_ be *null*.
        1. For each element _d_ of _lexDeclarations_, do
          1. NOTE: Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*).
            1. Else,
              1. Perform ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*).
        1. <ins>For each Record _m_ of _localModuleDeclarations_, do</ins>
            1. <ins>Perform AddModuleDeclaration(_m_.[[Name]], _m.[[Module]], _env_).</ins>
            1. <ins>Let _mo_ be GetModuleObject(_m_.[[Module]]).</ins>
            1. <ins>Perform ! _env_.InitializeBinding(_m_.[[Name]], _mo_).</ins>
        1. For each Parse Node _f_ of _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _env_ and _privateEnv_.
          1. Perform ? <emu-meta effects="user-code">_env_.CreateGlobalFunctionBinding</emu-meta>(_fn_, _fo_, *false*).
        1. For each String _vn_ of _declaredVarNames_, do
          1. Perform ? <emu-meta effects="user-code">_env_.CreateGlobalVarBinding</emu-meta>(_vn_, *false*).
        1. Return ~unused~.
      </emu-alg>
      <emu-note>
        <p>Early errors specified in <emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref> prevent name conflicts between function/var declarations and let/const/class<ins>/module</ins> declarations as well as redeclaration of let/const/class<ins>/module</ins> bindings for declaration contained within a single |Script|. However, such conflicts and redeclarations that span more than one |Script| are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the global object is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an abrupt completion and some global declarations not being instantiated. If this occurs, the code for the |Script| is not evaluated.</p>
        <p>Unlike explicit var or function declarations, properties that are directly created on the global object result in global bindings that may be shadowed by let/const/class<ins>/module</ins> declarations.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar><ins>Module : ModuleBody</ins></emu-grammar>
        <ul>
          <li>
            1. <ins>It is a Syntax Error if ContainsUndefinedModuleReference of |ModuleBody| with argument a new empty List is *true*.</ins>
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo" number="3">
        <h1>Static Semantics: ModuleRequests ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-grammar>ModuleSpecifier : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the <del>SV of |StringLiteral|</del><ins>ModuleSpecifier Record { [[Name]]: the SV of |StringLiteral|, [[Type]]: ~external~ }</ins>.
        </emu-alg>
        <emu-grammar>
          <ins>ModuleSpecifier : Identifier</ins>
        </emu-grammar>
        <emu-alg>
          1. <ins>Return a List whose sole element is the ModuleSpecifier Record { [[Name]]: the StringValue of |Identifier|, [[Type]]: ~internal~ }</ins>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>

        <emu-table id="table-abstract-methods-of-module-records" caption="Abstract Methods of Module Records" oldids="table-37">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <ins>GetExportedModule(_name_)</ins>
              </td>
              <td>
                <p><ins>Return the Module Record for the module exported by this module as _name_. If this module is a Cyclic Module Record, it can also return an ImportedModule Record representing a potential module which has been re-exported by a transitive dependency. It throws an error if there is no potential module export corresponding to _name_.</ins></p>

                <p><ins>Unless otherwise specified, the default implementation of this method is:</ins></p>
                <emu-alg>
                  1. <ins>Throw a *TypeError* exception.</ins>
                </emu-alg>
              </td>
            </tr>
            <tr>
              <td>
                LoadRequestedModules( [ _hostDefined_ ] )
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-module-GetModuleObject" type="abstract operation">
          <h1>
            <ins>
              GetModuleObject (
                _moduleRecord_: a Module Record,
              ): a Module Object
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates the Module Object corresponding to the _moduleRecord_ Module Record.</dd>
          </dl>

          <emu-alg>
            1. Let _moduleObject_ be OrdinaryObjectCreate(%Module.prototype%, &laquo; [[ModuleRecord]] &raquo;).
            1. Set _moduleObject_.[[ModuleRecord]] to _moduleRecord_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records" number="5">
        <h1>Cyclic Module Records</h1>

        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of <del>Strings</del><ins>ModuleSpecifier Records</ins>
              </td>
              <td>
                A List of <ins>Records representing</ins> all the |ModuleSpecifier| strings <ins>or identifiers</ins> used by the module represented by this record to request the importation of a module. The List is in source text occurrence order.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                a List of Records with fields [[Specifier]] (a <del>String</del><ins>ModuleSpecifier Record</ins>) and [[Module]] (a Module Record)
              </td>
              <td>
                A map from the specifier strings used by the module represented by this record to request the importation of a module to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins>LoadInternalModule( _name_ )</ins>
              </td>
              <td>
                <p><ins>Loads the internal module with the given name and returns a Module Record or, if the internal module could be imported from another module, an ImportedModule Record. It throws if an internal module named _name_ does ot exist.</ins></p>

                <p><ins>Unless otherwise specified, the default implementation of this method is:</ins></p>
                <emu-alg>
                  1. <ins>Throw a *TypeError* exception.</ins>
                </emu-alg>
              </td>
            </tr>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <p><ins>A <dfn id="modulespecifier-record" variants="ModuleSpecifier Records">ModuleSpecifier Record</dfn> represents the request to import a module. Each ModuleSpecifier Record has the fields defined in <emu-xref href="#table-modulespecifier-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-modulespecifier-record-fields" caption="ModuleSpecifier Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[Name]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>The name of the imported module. For example, it's the string `"foo"` in `import "foo";`</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[Type]]</ins>
              </td>
              <td>
                <ins>~internal~ or ~external~</ins>
              </td>
              <td>
                <ins>Whether the module is an internal module, that should be declared nested inside another module, or an external module, that should be loaded using the HostLoadImportedModule abstract operation.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>An <dfn id="importedmodule-record" variants="ImportedModule Records">ImportedModule Record</dfn> represents a module which is imported from another module. Each ImportedModule Record has the fields defined in <emu-xref href="#table-importedmodule-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-importedmodule-record-fields" caption="ImportedModule Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[Specifier]]</ins>
              </td>
              <td>
                <ins>a ModuleSpecifier Record</ins>
              </td>
              <td>
                <ins>The specifier of the module this module is imported from.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ImportName]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>The name of the imported module.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <p>A <dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each GraphLoadingState Record has the fields defined in <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref>:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                a PromiseCapability Record
              </td>
              <td>
                The promise to resolve when the loading process finishes.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                It is true if the loading process has not finished yet, neither successfully nor with an error.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                It tracks the number of pending HostLoadImportedModule calls.
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                It is a list of the Cyclic Module Records that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is ~empty~)
              </td>
              <td>
                It contains host-defined data to pass from the LoadRequestedModules caller to HostLoadImportedModule.
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>A <dfn id="blockedinternalimport-record" variants="BlockedInternalImport Records">BlockedInternalImport Record</dfn> represents an import from an internal module that cannot be handled, because the internal module is imported from another module that hasn't been loaded yet. Each BlockedInternalImport Record has the fields defined in <emu-xref href="#table-blockedinternalimport-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-blockedinternalimport-record-fields" caption="BlockedInternalImport Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[BlockerReferrer]]</ins>
              </td>
              <td>
                <ins>a Module Record</ins>
              </td>
              <td rowspan="2">
                <ins>[[BlockerReferrer]] and [[BlockerSpecifier]] together indicate the module that is currently preventing the internal module from being imported.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[BlockedSpecifier]]</ins>
              </td>
              <td>
                <ins>a ModuleSpecifier Record</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ImportName]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>It is the name of the expected module exported by ([[BlockerReferrer]], [[BlockerSpecifier]]).</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[BlockedReferrer]]</ins>
              </td>
              <td>
                <ins>a Cyclic Module Record</ins>
              </td>
              <td>
                <ins>It is the module that is currently blocked from importing the internal module.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[LocalName]]</ins>
              </td>
              <td>
                <ins>a String</ins>
              </td>
              <td>
                <ins>It is the local alias, in [[BlockedReferrer]], of the imported module.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-note>
          <p><ins>To better understand the contents of BlockedInternalImport Records, consider the three modules defined in <emu-xref href="#table-blockedinternalimport-example"></emu-xref>:</ins></p>
          <emu-table id="table-blockedinternalimport-example" caption="BlockedInternalImport Record Example">
            <table>
              <tr>
                <th>
                  Module
                </th>
                <th>
                  Source
                </th>
              </tr>
              <tr>
                <td>
                  <ins>_A_</ins>
                </td>
                <td>
                  <pre><code class="javascript">import { mod as module } from "B";</code><code class="javascript">import { value } from module;</code></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <ins>_B_</ins>
                </td>
                <td>
                  <pre><code class="javascript">export { myModule as mod } from "C";</code></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <ins>_C_</ins>
                </td>
                <td>
                  <pre><code class="javascript">export module myModule {</code><code class="javascript" style="padding-left:4ex">export const value = 1;</code><code class="javascript">}</code></pre>
                </td>
              </tr>
            </table>
          </emu-table>

          <p><ins>Assume that the loading process of external modules is asynchronous. When loading the dependencies of _A_, <code>module</code> cannot be resolved yet and it will be represented by the BlockedInternalImport Record { [[BlockerReferrer]]: _A_, [[BlockerSpecifier]]: the ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: "B" }, [[ImportName]]: <code>"mod"</code>, [[BlockedReferrer]]: _A_,[[LocalName]]: <code>"module"</code> }.</ins></p>

          <p><ins>When _B_ is loaded, <code>module</code> cannot be imported yet, because <code>mod</code> is not defined in _B_ but in one of its dependencies: the above BlockedInternalImport Record will be replaced by the BlockedInternalImport Record { [[BlockerReferrer]]: _B_, [[BlockerSpecifier]]: the ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: "C" }, [[ImportName]]: <code>"myModule"</code>, [[BlockedReferrer]]: _A_, [[LocalName]]: <code>"module"</code> }.</ins></p>

          <p><ins>Finally, after _C_ has finished loading, it's possible to load the <code>module</code> internal module. This logic is handled in the below InnerModuleLoading and ProcessBlockedInternalRequests algorithms.</ins></p>
        </emu-note>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything
            ): a Promise object
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Cyclic Module Record</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>optional _referrer_: a Cyclic Module Record,</ins>
                <ins>optional _specifier_: a ModuleSpecifier Record,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. <ins>If _referrer_ has been provided, then</ins>
                1. <ins>Assert: _specifier_ has been provided.</ins>
                1. <ins>Perform ProcessBlockedInternalRequests(_state_, _referrer_, _specifier_, _module_).</ins>
                1. <ins>If _state_.[[IsLoading]] is *false*, return.</ins>
              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the length of _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] + _requestedModulesCount_.
                1. For each ModuleSpecifier Record _required_ of _module_.[[RequestedModules]], do
                  1. <del>If _state_.[[IsLoading]] is *true*, then:</del>
                  1. If _module_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _required_, then
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], <ins>_module_, _required_</ins>).
                  1. <ins>Else if _required_.[[Type]] is ~internal~, then</ins>
                    1. <ins>Let _internalCompletion_ be Completion(_module_.LoadInternalModule(_required_.[[Name]])).</ins>
                    1. <ins>If AbortModuleLoading(_state_, _internalCompletion_) is *true*, return.</ins>
                    1. <ins>Let _internal_ be _internalCompletion_.[[Value]].</ins>
                    1. <ins>If _internal_ is a Module Record, then</ins>
                      1. <ins>Append Record { [[Specifier]]: _required_, [[Module]]: _internal_ } to _module_.[[LoadedModules]].</ins>
                      1. <ins>Perform InnerModuleLoading(_state_, _internal_, _module_, _required_).</ins>
                    1. <ins>Else,</ins>
                      1. <ins>Assert: _internal_ is an ImportedModule Record.</ins>
                      1. <ins>Append the Record { [[BlockerReferrer]]: _module_, [[BlockerSpecifier]]: _internal_.[[Specifier]], [[ImportName]]: _internal_.[[ImportName]], [[BlockedReferrer]]: _module_, [[LocalName]]: _required_.[[Name]] } to _state_.[[BlockedInternalImports]].</ins>
                  1. Else,
                    1. <ins>Assert: _required_.[[Type]] is ~external~.</ins>
                    1. Perform HostLoadImportedModule(_module_, <del>_required_</del><ins>_required_.[[Name]]</ins>, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call ContinueModuleLoading.
                  1. <ins>If _state_.[[IsLoading]] is *false*, return.</ins>
              1. <del>If _state_.[[IsLoading]] is *false*, return.</del>
              1. Assert: _state_.[[PendingModules]] &ge; 1.
              1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] - 1.
              1. If _state_.[[PendingModules]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ in _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a GraphLoadingState Record,
                <ins>_referrer_: a Cyclic Module Record,</ins>
                <ins>_specifier_: a ModuleSpecifier Record,</ins>
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return.
              1. <ins>If AbortModuleLoading(_state_, _moduleCompletion_) is *true*, return.</ins>
              1. <ins>Assert: _moduleCompletion_ is a normal completion.</ins>
              1. <del>If _moduleCompletion_ is a normal completion, then:</del>
              1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]], <ins>_referrer_, _specifier_</ins>).
              1. <del>Else,</del>
                1. <del>Set _state_.[[IsLoading]] to *false*.</del>
                1. <del>Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).</del>
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ProcessBlockedInternalRequests" type="abstract operation">
            <h1>
              <ins>
                ProcessBlockedInternalRequests (
                  _state_: a GraphLoadingState Record,
                  _referrer_: a Cyclic Module Record,
                  _specifier_: a ModuleSpecifier Record,
                  _module_: a Module Record,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd></dd>
            </dl>

            <emu-alg>
              1. For each Record _dep_ of _state_.[[BlockedInternalImports]] such that _dep_.[[BlockerReferrer]] is _referrer_ and _dep_.[[BlockerSpecifier]] is _specifier_, do
                1. Let _exportedCompletion_ be Completion(_module_.GetExportedModule(_dep_.[[ImportName]])).
                1. If AbortModuleLoading(_state_, _exportedCompletion_) is *true*, return.
                1. Assert: _exportedCompletion_ is a normal completion.
                1. Let _exported_ be _exportedCompletion_.[[Value]].
                1. If _exported_ is a Module Record, then
                  1. Let _internalSpecifier_ be the ModuleSpecifier Record { [[Type]]: ~internal~, [[Name]]: _dep_.[[LocalName]] }.
                  1. Append the Record { [[Specifier]]: _internalSpecifier_, [[Module]]: _exported_ } to _dep_.[[BlockedReferrer]].[[LoadedModules]].
                  1. Perform InnerModuleLoading(_state_, _exported_, _module_, _internalSpecifier_).
                  1. If _state_.[[IsLoading]] is *false*, return.
                1. Else,
                  1. Assert: _exported_ is an ImportedModule Record.
                  1. Remove _dep_ from _state_.[[BlockedInternalImports]].
                  1. Append the Record { [[BlockerReferrer]]: _module_, [[BlockerSpecifier]]: _exported_.[[Specifier]], [[ImportName]]: _exported_.[[ImportName]], [[BlockedReferrer]]: _dep_.[[BlockedReferrer]], [[LocalName]]: _dep_.[[LocalName]] } to _state_.[[BlockedInternalImports]].
            </emu-alg>

            <emu-note type="editor">
              TODO: Handle import cycles.
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-AbortModuleLoading" type="abstract operation">
            <h1>
              <ins>
                AbortModuleLoading (
                  _state_: a GraphLoadingState Record,
                  _completion_: a normal completion or a throw completion,
                ): a Boolean
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd></dd>
            </dl>

            <emu-alg>
              1. If _completion_ is a normal completion, return *false*.
              1. Set _state_.[[IsLoading]] to *false*.
              1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _completion_.[[Value]] &raquo;).
              1. Return *true*.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records" number="6">
        <h1>Source Text Module Records</h1>

        <p>In addition to the fields defined in <emu-xref href="#table-cyclic-module-fields"></emu-xref>, Source Text Module Records have the additional fields listed in <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref>. Each of these fields is initially set in ParseModule.</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="Additional Fields of Source Text Module Records" oldids="table-38">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                a Parse Node
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                an ECMAScript execution context
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                an Object
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                a List of ImportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <ins>[[VisibleModuleDeclarations]]</ins>
              </td>
              <td>
                <ins>a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)</ins>
              </td>
              <td>
                <ins>All the |ModuleDeclaration| declarations that are accessible from this module, either defined in this module or in a parent module. It does not contain two different records with the same [[Name]].</ins>
              </td>
            </tr>
          </table>
        </emu-table>
        <p>An <dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-importentry-record-fields"></emu-xref>:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                <del>a String</del><ins>a ModuleSpecifier Record</ins>
              </td>
              <td>
                <del>String value of</del><ins>The ModuleSpecifier Record representing</ins> the |ModuleSpecifier| of the |ImportDeclaration|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                a String or ~namespace-object~
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. The value ~namespace-object~ indicates that the import request is for the target module's namespace object.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                a String
              </td>
              <td>
                The name that is used to locally access the imported value from within the importing module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note class="module-overflow-note">
          <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> gives examples of ImportEntry records fields used to represent the syntactic import forms:</p>
          <emu-table id="table-import-forms-mapping-to-importentry-records" caption="Import Forms Mappings to ImportEntry Records" informative oldids="table-40">
            <table>
              <tr>
                <th>
                  Import Statement Form
                </th>
                <th>
                  [[ModuleRequest]]
                </th>
                <th>
                  [[ImportName]]
                </th>
                <th>
                  [[LocalName]]
                </th>
              </tr>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  ~namespace-object~
                </td>
                <td>
                  *"ns"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  <ins>`import {x as v} from mod;`</ins>
                </td>
                <td>
                  <ins>ModuleSpecifier Record { [[Type]]: ~internal~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  <ins>*"x"*</ins>
                </td>
                <td>
                  <ins>*"v"*</ins>
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  An ImportEntry Record is not created.
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>An <dfn id="exportentry-record" variants="ExportEntry Records">ExportEntry Record</dfn> is a Record that digests information about a single declarative export. Each ExportEntry Record has the fields defined in <emu-xref href="#table-exportentry-records"></emu-xref>:</p>
        <emu-table id="table-exportentry-records" caption="ExportEntry Record Fields" oldids="table-41">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                a String or *null*
              </td>
              <td>
                The name used to export this binding by this module.
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                a <del>String</del><ins>ModuleSpecifier Record</ins> or *null*
              </td>
              <td>
                The <del>String value of</del><ins>ModuleSpecifier Record representing</ins> the |ModuleSpecifier| of the |ExportDeclaration|. *null* if the |ExportDeclaration| does not have a |ModuleSpecifier|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                a String, *null*, ~all~, or ~all-but-default~
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. *null* if the |ExportDeclaration| does not have a |ModuleSpecifier|. ~all~ is used for `export * as ns from "mod"` declarations. ~all-but-default~ is used for `export * from "mod"` declarations.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                a String or *null*
              </td>
              <td>
                The name that is used to locally access the exported value from within the importing module. *null* if the exported value is not locally accessible from within the module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note class="module-overflow-note">
          <p><emu-xref href="#table-export-forms-mapping-to-exportentry-records"></emu-xref> gives examples of the ExportEntry record fields used to represent the syntactic export forms:</p>
          <emu-table id="table-export-forms-mapping-to-exportentry-records" caption="Export Forms Mappings to ExportEntry Records" informative oldids="table-42">
            <table>
              <tr>
                <th>
                  Export Statement Form
                </th>
                <th>
                  [[ExportName]]
                </th>
                <th>
                  [[ModuleRequest]]
                </th>
                <th>
                  [[ImportName]]
                </th>
                <th>
                  [[LocalName]]
                </th>
              </tr>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f() {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"f"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function () {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  ~all-but-default~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * as ns from "mod";`
                </td>
                <td>
                  *"ns"*
                </td>
                <td>
                  <del>*"mod"*</del><ins>ModuleSpecifier Record { [[Type]]: ~external~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  ~all~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  <ins>`export {x} from mod;`</ins>
                </td>
                <td>
                  <ins>*"x"*</ins>
                </td>
                <td>
                  <ins>ModuleSpecifier Record { [[Type]]: ~internal~, [[Name]]: *"mod"* }</ins>
                </td>
                <td>
                  <ins>*"x"*</ins>
                </td>
                <td>
                  <ins>*null*</ins>
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>

        <p>The following definitions specify the required concrete methods and other abstract operations for Source Text Module Records</p>

        <emu-clause id="sec-parsemodule" type="abstract operation" number="1">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: a Realm Record,
              _hostDefined_: anything,
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. <ins>Return BuildSourceTextModuleRecord(_body_, _realm_, _hostDefined_, a new empty List).</ins>
          </emu-alg>

          <emu-clause id="sec-buildsourcetextmodulerecord" type="abstract operation">
            <h1>
              <ins>
                BuildSourceTextModuleRecord (
                  _body_: a |Module| or |ModuleBody| Parse Node,
                  _realm_: a Realm Record,
                  _hostDefined_: anything,
                  _outerModuleDeclarations_: a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)
                ): a Source Text Module Record
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It creates a Source Text Module Record based upon the result of analysing _body_.</dd>
            </dl>
            <emu-alg>
              1. Let _requestedModules_ be the ModuleRequests of _body_.
              1. Let _importEntries_ be ImportEntries of _body_.
              1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
              1. Let _indirectExportEntries_ be a new empty List.
              1. Let _localExportEntries_ be a new empty List.
              1. Let _starExportEntries_ be a new empty List.
              1. Let _exportEntries_ be ExportEntries of _body_.
              1. For each ExportEntry Record _ee_ of _exportEntries_, do
                1. If _ee_.[[ModuleRequest]] is *null*, then
                  1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].
                    1. If _ie_.[[ImportName]] is ~namespace-object~, then
                      1. NOTE: This is a re-export of an imported module namespace object.
                      1. Append _ee_ to _localExportEntries_.
                    1. Else,
                      1. NOTE: This is a re-export of a single name.
                      1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
                1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                  1. Assert: _ee_.[[ExportName]] is *null*.
                  1. Append _ee_ to _starExportEntries_.
                1. Else,
                  1. Append _ee_ to _indirectExportEntries_.
              1. Let _async_ be _body_ Contains `await`.
              1. <ins>Let _visibleModuleDeclarations_ be InstantiateModuleDeclarations(_body_, _realm_, _hostDefined_, _outerModuleDeclarations_).</ins>
              1. <ins>Append each element of _outerModuleDeclarations_ to _visibleModuleDeclarations_.</ins>
              1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: &laquo; &raquo;, [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: a new empty List, <ins>[[VisibleModuleDeclarations]]: _visibleModuleDeclarations_,</ins> [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-instantiatemoduledeclarations" type="abstract operation">
            <h1>
              <ins>
                InstantiateModuleDeclarations (
                  _node_: a Parse Node,
                  _realm_: a Realm Record,
                  _hostDefined_: anything,
                  _outerModuleDeclarations_: a List of Records with fields [[Name]] (a String) and [[Module]] (a Module Record)
                ): a List of Records with fields [[Name]] (a String) and [[Module]] (a Source Text Module Record)
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It creates the Module Records corresponding to the |ModuleDeclaration|s directly contained within _node_.</dd>
            </dl>
            <emu-alg>
              1. Let _localModuleDeclarations_ be a new empty List.
              1. Let _visibleModuleDeclarations_ be a new empty List.
              1. Let _topLevelModuleDeclarations_ be the TopLevelModuleDeclarations of _node_.
              1. For each Parse Node _decl_ of _topLevelModuleDeclarations_, do
                1. Let _name_ be the sole element of the BoundNames of _decl_.
                1. Let _rec_ be the Record { [[Name]]: _name_, [[Module]]: ~empty~ }.
                1. Append _rec_ to _visibleModuleDeclarations_.
                1. Append _rec_ to _localModuleDeclarations_.
                1. NOTE: The [[Module]] field of this Record will be set to a Module Record before the end of this ParseModule operation. The ~empty~ value is never observable outside of ParseModule.
              1. If _outerModuleDeclarations_ is not empty, then
                1. Let _localDeclaredNames_ be the list-concatenation of the VarDeclaredNames of _node_ and the LexicallyDeclaredNames of _node_.
                1. For each Record _m_ of _outerModuleDeclarations_, do
                  1. If _m_.[[Name]] is not an element of _localDeclaredNames_ and _visibleModuleDeclarations_ does not contain a Record with [[Name]] equal to _m_.[[Name]], then
                    1. Append _m_ to _visibleModuleDeclarations_.
                1. TODO: Instead of copying all of them, we could just add the declarations that are imported inside this module. This would simplify structured cloning, since we wouldn't need to clone all the visible modules.
              1. For each Parse Node _decl_ of _topLevelModuleDeclarations_, do
                1. Let _name_ be the sole element of the BoundNames of _decl_.
                1. Let _rec_ be the Record in _localModuleDeclarations_ with [[Name]] equal to _name_.
                1. Assert: _rec_ exists and is unique.
                1. Let _moduleRecord_ be BuildSourceTextModuleRecord(_decl_'s |ModuleBody|, _realm_, _hostDefined_, _visibleModuleDeclarations_).
                1. Set _rec_.[[Module]] to _moduleRecord_.
              1. Return _localModuleDeclarations_.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method" number="4">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be ? _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleSpecifier]]).
              1. Assert: _importedModule_ is not ~empty~, because imported module requests are a subset of _module_.[[RequestedModules]], and these have been resolved earlier in this algorithm.
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. Else,
                1. Let _resolution_ be ? _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the ModuleDeclarationsEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _dn_ is not an element of _declaredVarNames_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
            1. <ins>For each Record _m_ in _m_.[[VisibleModuleDeclarations]], do</ins>
              1. <ins>TODO: _m_.[[VisibleModuleDeclarations]] doesn't contain module declarations imported from other files, but they should all be included.</ins>
              1. <ins>Perform AddModuleDeclaration(_m_.[[Name]], _m.[[Module]], _env_).</ins>
              1. <ins>Let _mo_ be GetModuleObject(_m_.[[Module]]).</ins>
              1. <ins>Perform ! _env_.InitializeBinding(_m_.[[Name]], _mo_).</ins>
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method" number="6">
          <h1>
            <ins>
              LoadInternalModule (
                _name_: a String,
              ): a throw completion, or a normal completion containing either a Module Record or a ImportedModule Record
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ImportEntry Record _entry_ of _module_.[[ImportEntries]], do
              1. If _entry_.[[LocalName]] is _name_, then
                1. If _entry_.[[ImportName]] is ~namespace-object~, throw a *TypeError* exception.
                1. Return the ImportedModule Record { [[Specifier]]: _entry_.[[ModuleRequest]], [[ImportName]]: _entry_.[[ImportName]] }.
            1. For each Record _r_ of _module_.[[VisibleModuleDeclarations]], do
              1. If _r_.[[Name]] is equal to _name_, then
                1. Return _r_.[[Module]].
            1. Throw a new *TypeError* exception.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-GetExportedModule" type="concrete method">
          <h1>
            <ins>
              GetExportedModule (
                _name_: a String,
              ): a throw completion, or a normal completion containing either a Module Record or a ImportedModule Record
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntries Record _entry_ of _module_.[[LocalExportEntries]], do
              1. If _entry_.[[ExportName]] is _name_, then
                1. If _entry_.[[ModuleRequest]] is *null*, then
                  1. Assert: _entry_.[[LocalName]] is a String.
                  1. For each Record _decl_ of _module_.[[VisibleModuleDeclarations]], do
                    1. If _decl_.[[Name]] is _entry_.[[LocalName]], then
                      1. Return _decl_.[[Module]].
                  1. Throw a new *TypeError* exception.
                1. Else if _entry_.[[ImportName]] is ~all-but-default~, then
                  1. Throw a new *TypeError* exception.
                1. Else if _entry_.[[ImportName]] is ~all~, then
                  1. TODO: Study how we can support this case, if needed.
                  1. Throw a new *TypeError* exception.
                1. Else,
                  1. Assert: _entry_.[[ImportName]] is a String.
                  1. Return the ImportedModule Record { [[Specifier]]: _entry_.[[ModuleRequest]], [[ImportName]]: _entry_.[[ImportName]] }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" number="8">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _specifier_: a String,
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. <ins>Let _specifierRecord_ be the ModuleSpecifier Record { [[Name]]: _specifier_, [[Type]]: ~external~ }.</ins>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is <del>_specifier_</del><ins>_specifierRecord_</ins>, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: <del>_specifier_</del><ins>_specifierRecord_</ins>, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _payload_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_payload_, <ins>_referrer_, _specifierRecord_,</ins> _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>Imports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause `;`
          `import` ModuleSpecifier `;`

        FromClause :
          `from` ModuleSpecifier

        ModuleSpecifier :
          StringLiteral
          <ins>Identifier</ins>
      </emu-grammar>

      <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo" number="3">
        <h1>
          Static Semantics: ImportEntriesForModule (
            _module_: a <del>String</del><ins>ModuleSpecifier Record</ins>,
          ): a List of ImportEntry Records
        </h1>
        <dl class="header">
        </dl>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>Exports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          <ins>`export` `default` ModuleDeclaration[+Default]</ins>
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class`, <ins>`module` [no LineTerminator here] `{`</ins> }] AssignmentExpression[+In, ~Yield, +Await] `;`
      </emu-grammar>

      <emu-clause id="sec-static-semantics-exportentriesformodule" type="sdo">
        <h1>
          Static Semantics: ExportEntriesForModule (
            _module_: a <del>String</del><ins>ModuleSpecifier Record</ins> or *null*,
          ): a List of ExportEntry Records
        </h1>
        <dl class="header">
        </dl>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
